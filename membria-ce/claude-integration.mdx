---
title: "Интеграция Membria + Claude Code"
description: "Vibe Coding с учетом принятых решений и персистентной памятью"
---

## Исполнительное резюме

Membria превращает Claude Code из генератора кода без состояния (stateless) в **партнера по разработке с учетом принятых решений**, который помнит историю проекта, учится на результатах и предотвращает повторение ошибок командой.

**Ключевое ценностное предложение:**
- **Для разработчиков:** ИИ, который помнит, что сработало, а что нет.
- **Для команд:** Общая память, которая сохраняется при смене персонала.
- **Для бюджетов:** Архитектура «Суперагента», которая в 10 раз дешевле мультиагентных альтернатив.

---

## Проблема: ИИ без состояния в Vibe Coding

### Что такое Vibe Coding
Vibe coding — это описание желаемого результата на естественном языке и передача написания кода ИИ. Это отлично работает для разовых скриптов и прототипов, но дает сбой в долгосрочных проектах.

### Где возникают проблемы

| Ситуация | Что происходит |
|-----------|--------------|
| Проект живет > 1 недели | ИИ не помнит вчерашних решений |
| Несколько разработчиков | Нет общего контекста между членами команды |
| Возврат к коду через месяц | «Почему это написано именно так?» — никто не знает |
| Похожая проблема решена ранее | ИИ снова совершает ту же ошибку |
| Плохой подход уже пробовали | Нет памяти → команда пробует его снова |

### Первопричина
Текущие ИИ-помощники по кодингу не имеют состояния (**stateless**): каждый промпт обрабатывается независимо, без памяти о прошлых архитектурных решениях или «негативных знаниях» (том, что провалилось).

---

## Решение: Архитектура Суперагента Membria

### Вместо множества агентов (Multi-Agent)
Типичные мультиагентные системы (Orchestrator → Planner → Coder → Reviewer) сжигают **70 000+ токенов** на задачу, так как каждый агент получает избыточный полный контекст.

### Подход Membria: Один агент + Умный контекст
```
✅ MEMBRIA SUPERAGENT:

Запрос пользователя
    ↓
┌─────────────────────────────────┐
│  Запрос к графу Membria         │  ← Локально, 0 токенов
│  "Что релевантно для этого?"    │
└─────────────────────────────────┘
    ↓
[Только нужный контекст: ~2K токенов]
    ↓
┌─────────────────────────────────┐
│  Один вызов Claude Code         │  ← 6-10K токенов всего
│  С инъекцией контекста          │
└─────────────────────────────────┘
    ↓
Код + Авто-фиксация записи решения
```
**Результат: в 10 раз меньше токенов, персистентная память, предсказуемые затраты.**

---

## Архитектура

```
┌─────────────────────────────────────────────────────────────────────┐
│                     IDE / PR / CI Layer                             │
│               (VS Code, GitHub PR, Jira, CI jobs)                   │
└─────────────────────────────────────────────────────────────────────┘
                                   │
                                   ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Claude Control Plane (CCP)                       │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                      Task Router                             │   │
│  │                                                              │   │
│  │  Классификация:                                              │   │
│  │  • Тактическая (без фиксации): "fix typo", "add logging"    │   │
│  │  • Решение (полный цикл): "choose library", "design API"    │   │
│  │  • Обучение (исход): "PR merged", "tests failed"            │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                   │                                 │
│         ┌─────────────────────────┼─────────────────────────┐      │
│         ▼                         ▼                         ▼      │
│  ┌─────────────┐         ┌─────────────┐         ┌─────────────┐  │
│  │ Тактическая │         │   Задача-   │         │   Задача-   │  │
│  │    задача   │         │   решение   │         │   обучение  │  │
│  │             │         │             │         │             │  │
│  │ Прямое исп. │         │ Полный цикл │         │Связь исхода │  │
│  └──────┬──────┘         └──────┬──────┘         └──────┬──────┘  │
│         │                       │                       │          │
│         │                       ▼                       │          │
│         │        ┌──────────────────────────┐          │          │
│         │        │  PRE-GENERATION          │          │          │
│         │        │  FETCH КОНТЕКСТА         │          │          │
│         │        │                          │          │          │
│         │        │  Запрос к Graph Memory:  │          │          │
│         │        │  • Прошлые решения       │          │          │
│         │        │  • Ошибочные подходы     │          │          │
│         │        │  • Паттерны команды      │          │          │
│         │        │  • Негативные знания     │          │          │
│         │        │                          │          │          │
│         │        │  Цена: 0 токенов (локал) │          │          │
│         │        └────────────┬─────────────┘          │          │
│         │                     ▼                        │          │
│         │        ┌──────────────────────────┐          │          │
│         │        │  DECISION SURFACE        │◄─────────┼──────┐   │
│         │        │  (внутри IDE)            │          │      │   │
│         │        │                          │          │Разработчик
│         │        │  Показ до генерации:     │          │ видит это
│         │        │  • Похожие решения       │          │ ДО ген-ции
│         │        │  • Что провалилось ранее │          │ кода      │   │
│         │        │  • Точность команды тут  │          │      │   │
│         │        │                          │          │      │   │
│         │        │  [Proceed] [Override]    │          │      │   │
│         │        └────────────┬─────────────┘          │          │
│         │                     ▼                        │          │
│         │        ┌──────────────────────────┐          │          │
│         │        │  ФИКСАЦИЯ РЕШЕНИЯ (DBB)  │          │          │
│         │        │                          │          │          │
│         │        │  Записи (неизменяемые):  │          │          │
│         │        │  • Что решено            │          │          │
│         │        │  • Отвергнутые варианты  │          │          │
│         │        │  • Уровень уверенности   │          │          │
│         │        └────────────┬─────────────┘          │          │
│         │                     │                        │          │
│         ▼                     ▼                        ▼          │
│  ┌─────────────────────────────────────────────────────────────┐  │
│  │                    Agent / TENN                              │  │
│  │                   (граф + логика)                            │  │
│  └─────────────────────────────────────────────────────────────┘  │
└───────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                 Policy Engine (на базе Графа)                       │
│                                                                     │
│  Статические правила: безопасность, комплаенс, стиль               │
│  Динамические правила: паттерны команды из Графа                   │
│  Детекция резонанса: проверка совпадения bias человека и ИИ         │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│              MCP Server (Claude Runtime Control)                    │
│                                                                     │
│  Инъекция контекста:                                               │
│  • Контекст решения из DBB                          ◄── Claude     │
│  • Негативное знание ("не делай X")                     Code       │
│  • Предпочтения и паттерны команды                  (stateless)    │
│                                                                     │
│  Управление инструментами, режимами и валидация вывода             │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│              Валидаторы после генерации (Post-Gen)                  │
│                                                                     │
│  • Код соответствует принятому решению?                            │
│  • Учтено ли "негативное знание"?                                  │
│  • Обнаружен ли самоуверенный язык (overconfidence)?               │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                    Membria Reasoning Graph                          │
│                                                                     │
│  Хранит:                                                           │
│  • Записи решений (неизменяемые)                                   │
│  • Предположения и их исходы                                       │
│  • Негативные знания (что провалилось)                             │
│  • Данные калибровки команды                                       │
│  • Связи: BLOCKS, RELIES_ON, SUPERSEDES                            │
└─────────────────────────────────────────────────────────────────────┘
                                    │
                                    │ (асинхронно)
                                    ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      Слой фиксации исходов                          │
│                                                                     │
│  События обязательств (авто-детекция):                              │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │ PR merged        → Решение исполнено                        │   │
│  │ Тесты пройдены   → Позитивный сигнал                        │   │
│  │ Тесты провалены  → Негативный сигнал                        │   │
│  │ Инцидент создан  → Сильный негатив                          │   │
│  │ 30 дней стабильно→ Позитивный исход                         │   │
│  │ 90 дней стабильно→ Сильный позитивный исход                 │   │
│  └─────────────────────────────────────────────────────────────┘   │
└───────────────────────────────────────────────────────────────────┘
```

---

## Результаты Vibe Coding

### 1. Меньше циклов «Генерация → Ошибка → Переделка»
Membria блокирует предложения Claude, которые ранее приводили к провалам (например, кастомная auth-middleware, имевшая проблемы с безопасностью 6 месяцев назад).
**Итог: Сокращение времени на переделки на 60%.**

### 2. Код остается понятным
Membria связывает выбор кода с конкретными Записями Решений. Вам не нужно гадать, почему был выбран Fastify вместо Express; причина зафиксирована в Графе.
**Итог: Самодокументируемая кодовая база.**

### 3. ИИ перестает повторять ошибки
Когда баг исправлен, Membria записывает его как «Негативное знание». В следующий раз Claude получит контекст, запрещающий использовать этот паттерн.
**Итог: Обучение на специфике проекта.**

---

## Экономика токенов: Суперагент vs Мультиагент

| Аспект | Мультиагент | Суперагент Membria |
|--------|-------------|-------------------|
| Токенов на задачу | 70,000+ | 6,000-10,000 |
| Цена в месяц (5 дев) | $640-2,400 | $245 (фикс) |
| Память | Отсутствует | Персистентная (Граф) |
| Масштабируемость | Линейный рост цены | Фикс. подписка |

**Вендоры мультиагентных систем хотят, чтобы вы использовали БОЛЬШЕ агентов для заработка. Membria хочет, чтобы вы использовали ЛУЧШИЙ контекст для экономии токенов.**

---

## Итог

Мультиагентная архитектура решает задачу «как разделить работу», создавая новую проблему: фрагментацию контекста. **Membria Superagent** решает первопричину: **предоставление одному агенту правильного контекста.**

**Vibe coding перестает быть «генерацией с нуля каждый раз» и становится «генерацией с памятью проекта».**
