---
title: "Причинно-следственная память"
description: "Разграничение между наблюдением и интервенцией в Graph Memory."
---

# Слой причинно-следственной памяти (Causal Memory)

Слой Causal Memory расширяет Reasoning Graph Membria, внедряя формальные структурные каузальные модели (SCM). Его основная цель — отличить простую корреляцию (наблюдение) от истинной причинности (интервенция), предотвращая ситуации, когда агенты полагаются на эвристики, не выдерживающие эмпирической проверки.

## 1. Слой интервенции ($do(x)$)

В стандартных RAG-системах данные пассивны ($P(Y|X)$). Membria рассматривает **Решения** как активные интервенции ($P(Y|do(X))$).

### События обязательств (Commitment Events) как операторы
Интервенция фиксируется только тогда, когда происходит **Commitment Event** (например, слияние PR, подписание контракта, исполнение API-вызова). Это позволяет системе различать:
- **Наблюдение:** «Пользователи жалуются на функцию X» (Контекст).
- **Интервенция:** «Мы отключили функцию X» (Действие).

### Интеграция с состоянием убеждений (Belief State)
Каждая интервенция запускает **байесовское обновление** в [движке POMDP](/rg-architecture#112-pomdp-belief-state-tracking). Система рассчитывает $P(Consensus)$ для интервенции и отслеживает поверхностное согласие через экстракцию сигналов (см. [Cognitive Safety — Signal Extraction](/cognitive-safety#4-signal-extraction-quality)).

### Правило каузальной валидности
Если результат $Outcome(Y)$ идентичен как для $do(Action)$, так и для $do(Nothing)$ внутри одного контекста, действие классифицируется как **Ритуал** (не имеющее причинной связи). В будущем система будет блокировать пути рассуждений, предлагающие это действие для достижения того же результата.

---

## 2. Стратифицированное извлечение (Контроль мешающих факторов — Confounders)

Для решения **проблемы мешающих факторов** ($X \leftarrow Z \rightarrow Y$), Membria использует векторную стратификацию контекста.

### Алгоритм
Когда агент предлагает причинно-следственную связь $X \rightarrow Y$:
1. **Идентификация мешающих факторов ($Z$):** Retrieval Orchestrator сканирует граф на наличие переменных $Z$, которые исторически коррелировали и с $X$, и с $Y$ (например, сезонность, маркетинговые расходы).
2. **Стратификация контекста:** Запрос к FalkorDB ограничивается подграфами, где $Z$ соответствует текущему состоянию.
3. **Сравнение исходов:** Система оценивает распределение $Y$ при заданном $X$ *только* внутри этого слоя (страты).

> [!IMPORTANT]
> Это гарантирует, что если «Продажи упали в июле» на фоне PR-кризиса, система корректно припишет падение «Низкому сезону» ($Z$), а не «PR-кризису» ($X$), если другие периоды «Низкого сезона» без кризисов показывали такое же падение.

---

## 3. Артефакты негативного знания

Негативное знание — это формализованная запись отвергнутых каузальных гипотез.

### Схема в FalkorDB
Каждый узел `NegativeKnowledge` содержит:
- `Hypothesis_Vector`: Семантический эмбеддинг отвергнутой идеи.
- `Causal_Weight`: Установлен $\approx 0$ или отрицателен.
- `Evidence_Links`: Ссылки на конкретные Решения и Исходы, которые опровергли связь.
- `Context_Constraints`: Условия, при которых связь была признана ложной.

---

## 4. Атомарная реализация в FalkorDB

Благодаря хранению векторов напрямую в узлах графа, FalkorDB позволяет выполнять **атомарные каузальные проверки**.

```cypher
// Атомарная проверка предложения X в контексте Z
CALL db.idx.vector.queryNodes('Assumptions', 'embedding', 3, vecf32($proposal_vector))
YIELD node as assumption, score
MATCH (assumption)<-[:RELIED_ON]-(d:Decision)-[:HAS_OUTCOME]->(o:Outcome)
WITH assumption, d, o, score
CALL db.idx.vector.queryNodes('Decision', 'context_z', 1, vecf32($current_z_vector))
YIELD node as ctx_match, score as z_score
WHERE d = ctx_match AND z_score > 0.8
RETURN assumption.statement, avg(o.delta) as causal_impact
```

## 5. Калибровка Допущений со Стратификацией (Assumption Calibration)

Обновления Beta-распределения должны быть стратифицированы, чтобы избежать смешивания сигналов из разных контекстов (например, рыночные условия, регионы).

**Формула:**
`Beta(α, β) → Beta(α + w·outcome, β + w·(1-outcome))`

Где:
`w = recency_weight × confounder_match_score`

**Измерения стратификации:**
- **Географический/Культурный контекст:** "Вендор надежен" (True в ЕС, False в Азии).
- **Временная свежесть (Temporal Recency):** Взвешенное затухание гарантирует, что недавние исходы доминируют.
- **Идентифицированные конфаундеры:** Исходы привязаны к конфаундерам (например, "Рыночный бум"), чтобы предотвратить ложную атрибуцию мастерства.
