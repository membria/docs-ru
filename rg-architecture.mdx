---
title: "Архитектура Reasoning Graph"
description: "Архитектура Reasoning Graph: GraphRAG, DBB/DS, кэш и жизненный цикл LoRA."
---

## Обзор

Этот документ содержит описание промышленного уровня архитектуры Reasoning Graph (Граф Рассуждений) в Membria: совместная работа GraphRAG, памяти, DBB/DS, кэша знаний и жизненного цикла LoRA.

---

## 1. Что такое Reasoning Graph в Membria

**Reasoning Graph** — это слой между пользователем (или командой) и любыми ИИ-моделями, который делает интеллект **накопительным**, а не одноразовым.

Он решает одну фундаментальную проблему:

> В обычном ИИ интеллект «растворяется» в чатах — много разговоров, но мало устойчивой структуры. Reasoning Graph превращает поток взаимодействий в стабильную, многоразовую память с причинно-следственными связями, доказанным происхождением и возможностью управления (governance).

Reasoning Graph реализует:
- **Темпоральный граф знаний, ориентированный на решения (Decision-centric)**
- **GraphRAG с учетом бюджета (Budget-aware)**
- **Управляемую петлю обучения**

---

## 2. Основные подсистемы Reasoning Graph

Reasoning Graph реализован как набор взаимосвязанных подсистем:

| # | Подсистема | Функция |
| --- | --- | --- |
| 1 | **Ingestion + Normalization** | Подключение источников, извлечение контента, нормализация к каноническому виду |
| 2 | **Event / Decision Extraction (DBB)** | Фоновый агент, превращающий шум (чаты/доки/комментарии) в события, решения, предположения, исходы |
| 3 | **Graph Memory (Temporal / Causal)** | Долговременная память в виде графа: люди, документы, решения, причины, следствия, версии, временные диапазоны |
| 4 | **Vector Memory (Embeddings)** | Семантическая память: эмбеддинги фрагментов, узлов, событий, схожесть кейсов |
| 5 | **Knowledge Cache (Local + Shared)** | Повторное использование проверенных ответов, паттернов рассуждений, выводов |
| 6 | **Retrieval Orchestrator (GraphRAG Router)** | Роутер, решающий: что извлекать (граф, векторы, кэш), объем контекста, необходимость эскалации |
| 7 | **Decision Intelligence Engine** | Слой для **VoI-скоринга**, **POMDP-трекинга убеждений** и **оптимизации последовательностей** |
| 8 | **Model Runtime (Local-first + Council)** | Быстрая локальная модель обрабатывает 80-95% работы; сложные случаи эскалируются в Совет (Council) |
| 9 | **LoRA Lifecycle + Router Policy** | Механизм накопления экспертизы: новые LoRA-адаптеры на основе пробелов, их валидация, деплой/откат |
| 10 | **Decision Surface (DS)** | UI/система сигналов: открытые петли, скрытые разногласия, дрифт и риски, ранжированные по VoI |

---

## 3. Объекты данных в Reasoning Graph

### 3.1 Каноническая единица — Evidence (Доказательство)

Каждый фрагмент входных данных нормализуется в **Evidence Record**:

```
Evidence Record:
- source_type    (chat/doc/email/issue/voice/log/...)
- source_id      (ссылка на оригинал)
- actor          (кто написал/сказал/одобрил)
- timestamp
- content        (текст/экстракт)
- hash           (хэш контента для неизменяемости)
- access_scope   (права доступа/tenant/domain)
- embedding      (опционально)
```

### 3.2 События и решения

DBB создает структурированные объекты:

**Event (Событие):**
```
Event:
- event_type       (proposal_updated, risk_flagged, decision_candidate, assumption_changed...)
- entities         (к чему/кому относится)
- evidence_links[] (ссылки на источники)
- confidence       (вероятность корректности интерпретации)
- time_range       (если событие длительное)
```

**Decision (Решение):**
```
Decision:
- decision_id
- statement        ("Выбираем X", "Релиз отложен на 2 недели", "Цепочка UBO принята")
- alternatives[]   (если извлечены)
- rationale        (обоснование, желательно структурированное)
- assumptions[]
- value_of_information: {
    score: float,
    basis: string,
    computed_at: timestamp
  }
- belief_state: {
    state: "consensus" | "surface_agreement" | "misunderstanding",
    prob_true_consensus: float,
    prob_surface_only: float,
    prob_misunderstanding: float,
    confidence: float,
    last_updated: timestamp
  }
- constraints[]
- owner            (кто принимает решение)
- status           (draft / pending / approved / overturned)
- outcomes[]       (результаты и метрики, когда появятся)
- evidence_links[]
- confidence
```

### 3.3 Память — это не лог чата

Ключевой принцип Reasoning Graph: храним структуру, а не все слова:
- Решения и их контекст
- Причинно-следственные связи
- Происхождение фактов (provenance)
- Изменения во времени
- Исходы (outcomes)

---

## 4. Как DBB превращает хаос в память

DBB — это не UI, а бэкенд-процесс/агент. Его задача: детектировать моменты принятия решений и записывать их, подобно «черному ящику» самолета.

### 4.1 Сбор и нормализация событий

Reasoning Graph опирается на нормализованный поток событий из внешних систем (электронная почта, DMS, биллинг, идентификация и т. д.).

Этот слой отвечает за:
- Получение событий из внешних источников
- Нормализацию событий в единый формат
- Дедупликацию
- Темпоральное упорядочивание внутри объектов
- Сохранение ссылок на исходные системы

Слой сбора событий не интерпретирует их смысл и не принимает решений. Он предоставляет DBB фактическую, верифицируемую основу для построения Окон Принятия Решений (Decision Windows) и идентификации Событий Обязательств (Commitment Events).

### 4.2 Слой необратимости и Commitment Events

В Reasoning Graph необратимость решения не определяется LLM и не выводится из текста. Она устанавливается через внешние **Commitment Events** — факты изменений в реальном мире, которые не могут или не должны быть отменены бесследно.

Reasoning Graph принципиально различает:
- Обсуждение
- Намерение
- Решение
- Необратимое действие

DBB не создает необратимость. Он лишь связывает решения с уже произошедшими необратимыми событиями.

#### Commitment Event (Событие Обязательства)

Commitment Event — это событие, которое:
- Имеет внешний эффект (технический, финансовый, юридический, организационный)
- Фиксируется во внешней системе
- Служит точкой принятия обязательств (точкой невозврата)

Примеры Commitment Events:
- PR влит (merged) или релиз опубликован
- Счет выставлен
- Платеж исполнен
- Контракт подписан
- Письмо отправлено внешнему адресату
- Предоставлен доступ или роль
- Изменена политика или права доступа

Commitment Events попадают в Reasoning Graph через логгер событий и обрабатываются как факты, а не интерпретации.

#### Decision Window (Окно Принятия Решения)

Решение в Reasoning Graph рассматривается не как сообщение, а как Decision Window — временное окно событий, внутри которого произошло необратимое действие.

Decision Window включает:
- pre-context: обсуждения, альтернативы, согласования
- trigger: событие обязательства (commitment event)
- post-effects: последствия и последующие события
- actors: участники и владельцы
- linked systems: источники событий

Decision Window является основным объектом анализа DBB и фундаментом для фиксации решения.

#### Роль DBB

DBB работает поверх логгера событий и:
- Агрегирует события в Decision Windows
- Идентифицирует наличие Commitment Events
- Оценивает риски и уверенность
- Формирует кандидатов в решения
- Применяет политику для фиксации или запроса подтверждения

DBB не определяет факт необратимости. Он использует необратимость, уже зафиксированную внешними системами.

#### Политика фиксации решений

Фиксация решения в DBB возможна только при выполнении одного из условий:
1. В Decision Window присутствует Commitment Event
2. Пользователь явно инициировал фиксацию решения (explicit capture)

Во всех остальных случаях DBB может только:
- Сохранять контекст
- Формировать кандидатов
- Ожидать подтверждения

Это предотвращает ложные решения и исключает автоматическую фиксацию только на основе текста.

#### Связь с неизменяемым хранилищем

Commitment Events и записи о решениях могут быть:
- Привязаны к журналу только для записи (append-only)
- Закреплены в блокчейне (Membria CE / peaq)
- Подписаны для невозможности отказа от авторства (non-repudiation)

В этом случае:
- Контент и персональные данные (PII) хранятся вне сети (off-chain)
- В сети фиксируются только хэши, ссылки и метаданные

Необратимость в Reasoning Graph достигается не через LLM, а через:
```
Commitment Event -> Decision Window -> Policy -> Immutable Record
```

### 4.3 Идентичность решения

Каждое решение в Reasoning Graph имеет стабильный `decision_id`, который сохраняется на протяжении всего жизненного цикла решения.

Подтверждение, пересмотр, отмена или замена решения не создают новое решение — они меняют состояние существующего `decision_id`.

Это позволяет:
- Ссылаться на решения из внешних систем
- Отслеживать эволюцию решения
- Формировать корректные цепочки подотчетности

### 4.4 Область действия (Scope)

Каждое решение в Reasoning Graph имеет явно определенную область действия — границы применимости решения.

Scope может включать:
- Организационный уровень (оргструктура, команда, проект)
- Систему или продукт
- Клиента или группу пользователей
- Дополнительные ограничения (регион, среда, период)

Решения вне своей области действия не считаются конфликтующими по умолчанию.

### 4.5 Срок действия и условия

Решение в Reasoning Graph может иметь:
- Период действия
- Условия валидности
- Контекстную применимость

Истечение срока или условий не удаляет решение — оно переводит его в состояние `expired`.

Исторические решения остаются частью памяти и могут использоваться для анализа и обучения, но не для активных рассуждений.

### 4.6 Конфликты и замена (Supersession)

Reasoning Graph допускает существование конфликтующих решений.

При обнаружении конфликта Reasoning Graph:
- Фиксирует факт конфликта
- Указывает затронутые `decision_id`
- Связывает конфликт с политикой или ответственным лицом

Reasoning Graph не выбирает правильное решение автоматически. Разрешение конфликта — это всегда политическое или человеческое действие, фиксируемое как событие.

### 4.7 Человеческий override и границы автоматизации

Reasoning Graph допускает ручное вмешательство авторизованных пользователей.

Любое действие по переопределению (override):
- Фиксируется как событие
- Не удаляет историю
- Становится частью Decision Window

Reasoning Graph принципиально НЕ:
- Определяет правильность решения
- Оптимизирует бизнес-показатели
- Заменяет управление (governance)
- Принимает решения без политики
- Фиксирует решения без события обязательства или явного подтверждения

### 4.8 Оценка уверенности (Confidence scoring)

Как DBB решает «это решение или шум»:

Лингвистические маркеры:
- Наличие лексики обязательств («сделаем», «выпускаем», «одобряю», «я беру на себя»)
- Наличие конкретики (дедлайн, владелец, объект изменений)
- Наличие альтернатив или выбора («A vs B -> B»)

Контекстные маркеры:
- В треде был конфликт или обсуждение, за которым последовало закрытие
- Решение сопровождается действиями (создан тикет, PR, документ)
- Решение подтверждено вторым лицом («+1», «подтверждаю»)

Качество источника:
- Сообщения от ролей владельцев или аппруверов имеют больший вес
- Документы и политики весомее мнений в чате
- Наличие ссылок на первичные источники повышает уверенность

Анти-шум:
- Слишком общие формулировки без объекта («нужно улучшить»)
- Отсутствие доказательств (evidence)
- Повторение паттерна или спам-поведение
- Противоречия между сообщениями

Результат:
- confidence &ge; T_high -> решение записывается как зафиксированное
- T_low &le; confidence &lt; T_high -> кандидат, требует легкой валидации
- &lt; T_low -> не записывается как решение, только как событие или игнорируется

### 4.9 Исправление ложных срабатываний без трения

Правильный UX-паттерн: не модальное окно, а тихое исправление:
- Decision Surface показывает: «Зафиксировано решение (низкая уверенность)»
- У пользователя 2 кнопки: Подтвердить или Отклонить, плюс «Редактировать формулировку»
- Если отклонить -> DBB учится (негативный пример), но запись остается как сырое событие (не как решение)
- Если редактировать -> сохраняем связь: оригинал -> исправлено (важно для обучения)

---

## 5. GraphRAG: Извлечение знаний с учетом причинности

Стандартный RAG: «Найти похожие фрагменты текста -> скормить модели».

GraphRAG в Reasoning Graph: сначала фильтруем разрешенную область графа, затем извлекаем релевантные подграфы, и только потом применяем семантику.

### 5.1 Что хранит граф

Типичные узлы:
- Person / Team / Role (Кто)
- Document / Policy / Spec / Ticket / PR / MessageThread (Где/Что)
- Decision / Assumption / Outcome (Результат рассуждения)
- Entity (Customer, Project, System, Vendor, Regulation...)
- Event (Событие от DBB)

Типичные связи:
- DECIDED_BY
- BASED_ON (решение -> доказательство)
- AFFECTS (решение -> сущность)
- DEPENDS_ON
- CONFLICTS_WITH
- SUPERSEDES (версионность)
- HAS_OUTCOME
- MENTIONED_IN или DERIVED_FROM
- VALID_IN_TIME_RANGE

### 5.2 Алгоритм извлечения (Retrieval)

Когда поступает запрос пользователя:

1. Определение намерения: вопрос, действие, анализ, поиск прецедента.
2. Определение домена или области (scope): личный, workspace, проект, политика.
3. Фильтр RBAC или тенанта: выбирается только разрешенная область графа.
4. Подграф: берутся узлы вокруг ключевых сущностей.
5. Векторный поиск внутри подграфа: поиск ближайших доказательств или решений.
6. Темпоральный фильтр: последние 90 дней или на конкретную дату.
7. Сборка контекста: решения + обоснования + источники.
8. Ответ локальной моделью с указанием происхождения (provenance).

Это обеспечивает ответы «аудиторского» уровня: не «я так думаю», а «я утверждаю это, потому что вот цепочка источников».

### 5.3 Итеративный цикл сборки контекста

Сложные запросы обрабатываются через итеративный цикл сборки контекста:

```
query ->
  partial answer ->
    conflict and confidence check ->
      retrieve next fragment ->
        refinement ->
          stop or escalate
```

Каждая итерация фиксируется, а промежуточные выводы оформляются как временные гипотезы.

Свойства итеративного цикла:
- Каждая итерация записывается как событие
- Гипотезы представлены как временные узлы графа
- Финальный результат оформляется как Решение (Decision) или Артефакт Знания (Knowledge Artifact)
- Исчерпание бюджета ведет к остановке или эскалации, а не к расширению контекста

### 5.4 Retrieval Orchestrator (GraphRAG с учетом бюджета)

Retrieval Orchestrator реализован как движок политик, который управляет сборкой контекста в рамках явных ограничений, а не расширяет его до максимально возможного объема.

Контекст считается достаточным не по полноте, а по соблюдению заданных бюджетов.

#### Context Assembly Session (CAS)

Каждый запрос пользователя обрабатывается в рамках Сессии Сборки Контекста (CAS).

CAS служит:
- Единицей контроля
- Единицей аудита
- Единицей объяснимости (explainability)

#### Явные бюджеты контекста

В каждой сессии CAS применяются обязательные бюджеты:

| Бюджет | Определение |
| --- | --- |
| **edge_budget** | Максимальное количество ребер графа, которые можно пройти за одну сессию |
| **step_budget** | Максимальное количество шагов рассуждения и итераций сборки контекста |
| **token_budget** | Максимальный объем текста, передаваемый модели |
| **risk_budget** | Допустимый уровень неопределенности, противоречий и неполноты контекста |

Бюджеты устанавливаются политиками (тенанта, проекта, сценария), логируются и сохраняются как часть CAS.

#### Поведение при исчерпании бюджета

Исчерпание бюджета не является ошибкой. Это формальный сигнал для одного из действий:
- Остановить сборку и сгенерировать ответ на основе текущего контекста
- Эскалировать запрос
- Запросить подтверждение через Decision Surface

Расширение контекста сверх бюджетов не допускается.

#### Трейс сборки контекста (Context Assembly Trace)

Каждая CAS сохраняет трейс сборки контекста, включая:
- Какие элементы были расширены
- Почему
- Какие элементы были отброшены
- На каком шаге сборка остановилась
- Какой бюджет стал ограничивающим

Трейс сборки контекста используется для:
- Воспроизводимости
- Объяснимости
- Аудита
- Отображения в Decision Surface

---

## 6. Память Reasoning Graph: что помнит Membria

Память Reasoning Graph многослойна:

### 6.1 Рабочий контекст (оперативная память)
- Текущие задачи, активные решения, открытые вопросы
- Короткий горизонт (дни или недели)
- Используется для непрерывности между сериями чатов

### 6.2 Графовая память (долгосрочная)
- Решения, предположения, исходы, версии документов
- Причинность, таймлайн, кто одобрил

#### Темпоральная валидность

Каждое ребро графа имеет временную область действия, определенную полями `valid_from` и `valid_to`.

Каждое решение имеет явный временной диапазон применимости.

Процедуры извлечения контекста всегда отвечают на вопрос: «на какую дату проводится анализ?».

### 6.3 Векторная память (семантическая)
- Похожие кейсы, похожие формулировки, как мы решали раньше

### 6.4 Кэш знаний (повторное использование ответов)

Если вопрос уже был решен и ответ верифицирован — вернуть его без повторной генерации.

Типы кэша:
- Локальный (личный или командный)
- Глобальный или федеративный (децентрализованный бэкенд знаний)

#### Типы кэшированных артефактов

Кэш знаний хранит результаты рассуждений:

1. Answer Artifact (Артефакт ответа)
   - Вопрос
   - Ответ
   - Происхождение (Provenance)
   - Уверенность (Confidence)

2. Reasoning Pattern (Паттерн рассуждения)
   - Типичный вывод: «в таких условиях обычно X»

3. Negative Knowledge (Негативное знание)
   - Решение, которое оказалось ошибочным
   - Условия, при которых произошел сбой

Негативное знание является равноправным типом артефакта и используется для предотвращения повторных ошибок.

### 6.5 Почему важен децентрализованный бэкенд

Он нужен не для утечки приватных данных, а для того чтобы:
- Хранить многоразовые анонимизированные артефакты (паттерны, решения, исправления)
- Обеспечивать переносимость между устройствами
- Предоставлять общий слой результатов Совета (если позволяет политика)

---

## 7. Рантайм: Local-first + Эскалация (Совет)

### 7.1 Почему локально

Поскольку Reasoning Graph хранит долгосрочную память, это означает:
- Много данных
- Личный контекст
- Приватность критична
- Важна задержка (latency)

Локальная модель плюс локальный GraphRAG обрабатывают от 80 до 95 процентов запросов.

### 7.2 Когда локальной модели недостаточно

Триггеры эскалации:
- Уверенность ниже порога
- Обнаружено противоречие в графе
- Высокий риск (финансы, compliance, юридические вопросы)
- Запрос требует редкой экспертизы, которой нет в LoRA или кэше
- Новая область, где нет исторических решений

### 7.3 Порядок эскалации

1. Глобальный или общий кэш знаний: есть ли уже проверенный ответ?
2. Совет (Council): параллельный запрос к нескольким сильным моделям
3. Синтез: сборка консенсуса плюс проверка на противоречия с графом
4. Кэш: результат сохраняется как верифицированный артефакт знания
5. Детекция пробелов: повторяющиеся эскалации становятся кандидатами на создание LoRA

---

## 8. Жизненный цикл LoRA: как накапливается экспертиза

Важно: LoRA не делает модель умнее в целом. LoRA делает модель точнее в узком домене и снижает количество эскалаций.

### 8.1 Откуда берутся данные для LoRA

Три основных категории:

1. Связка «Решение -> Исход» (Feedback)
- DBB зафиксировал решение
- Позже появился результат (outcome)
- Reasoning Graph понимает: решение было успешным или провальным
- Формируется обучающий пример: какое рассуждение было верным в этих условиях

2. Дистилляция Совета (Council distillation)
- Совет дал сильный ответ или план
- Reasoning Graph сравнил: в чем ошиблась локальная модель? почему?
- Формируются пары: вопрос -> паттерн правильного ответа
- Это закрывает пробел в знаниях (knowledge gap)

3. Доменные пакеты (опционально)
- Правила, политики, гайды, плейбуки
- Особенно полезно в Enterprise или SMB

### 8.2 Governance: почему бесконтрольное самообучение запрещено

Иначе LoRA становится каналом отравления данных (data poisoning):
- Пользователь или сотрудник может намеренно подсовывать «мусор»
- Может возникнуть дрифт (drift)
- Качество может деградировать (рост галлюцинаций)

Обязательный цикл:
1. Генерация кандидата (авто)
2. Eval dataset (фиксированные тестовые промпты + кейсы известных сбоев)
3. Offline eval (точность, галлюцинации, эскалации)
4. Canary rollout (на части запросов)
5. Promote или Rollback (мгновенный откат)
6. Версионирование (каждая LoRA имеет версию и метрики)

### 8.3 Политика роутера LoRA

Роутер оценивает:
- Соответствие домену
- Историческую пользу LoRA (на eval + в продакшене)
- Текущие политики риска
- Базовую уверенность без LoRA
- Гарантию отсутствия деградации (если LoRA повышает вероятность галлюцинации -> запрещено)

Правило безопасности: если LoRA включена, но уверенность все равно низкая — эскалировать, а не выдумывать.

### 8.4 Обоснование LoRA (Justification Record)

Каждый LoRA-адаптер сопровождается Записью об Обосновании (LoRA Justification Record), содержащей:
- Причину появления LoRA
- Выявленные пробелы
- Ожидаемый эффект
- Потенциальные риски

Использование LoRA без задокументированного обоснования не допускается.

### 8.5 Типы и границы LoRA

| Тип LoRA | Цель | Может изменять | Не может изменять |
|-----------|---------|------------|---------------|
| **Калибровка** | Корректировка оценки уверенности | Уверенность вывода | Шаги рассуждения |
| **Домен** | Добавление доменных знаний | Извлечение фактов | Каузальные утверждения |
| **Дебиасинг (Debiasing)** | Внедрение дебиасинг-промптов | Промпты рассуждения | Решения пользователя |

> [!WARNING]
> **ЗАПРЕЩЕНО:** LoRA, маскирующие искажения без устранения первопричины.
> **ОБЯЗАТЕЛЬНО:** Все LoRA должны включать аудит трейса рассуждений.

---

## 9. Как все это соединяется: Цикл Накопления (Compound Cycle)

Полный цикл работы:

1. Пользователь взаимодействует в обычном режиме (чат, код, документы)
2. DBB извлекает события и решения, связывает их с источниками
3. Решения записываются в граф (с причинностью и временем)
4. DS показывает сигналы: что открыто, что дрейфует, что требует подтверждения
5. При новом запросе Reasoning Graph сначала ищет в графе и кэше, затем дает контекст локальной модели
6. Если локальной модели недостаточно -> эскалация в Совет
7. Результат Совета синтезируется, проверяется на конфликты в графе, кэшируется
8. Повторяющиеся пробелы становятся кандидатами в LoRA
9. LoRA проходит оценку, развертывается, снижает эскалации в будущем
10. Система становится точнее и персональнее без потери контролируемости

Так интеллект суммируется, а не сбрасывается.

---

## 10. Как Reasoning Graph защищает от «мусора» на входе

Минимальные эвристики защиты:

| Защита | Описание |
| --- | --- |
| Вес источника | Документы, политики, подписи имеют более высокий ранг, чем слова в чате |
| Вес роли | Владелец (Owner) или Аппрувер имеют больший вес |
| Требование доказательств | Важные решения без источников не получают продвижения |
| Проверки противоречий | Если в графе есть конфликт — повышаем риск или запрашиваем подтверждение |
| Темпоральная чистота | Решение не может ссылаться на событие из будущего |
| Детекция спама и повторов | Одинаковые формулировки, странные паттерны |
| Canary и Rollback для LoRA | Любая деградация -> мгновенный откат |

---

## 11. Слой Decision Intelligence

Слой Decision Intelligence (DI) расширяет возможности Reasoning Graph от простого сохранения знаний до **оптимизации совместных решений человека и ИИ**.

### 11.1 Скоринг ценности информации (VoI)
Membria приоритизирует открытые петли и сбор информации на основе **Ценности Информации (Value of Information, VoI)**.
- **Цель:** Направить внимание пользователя на решения, где получение новых данных дает наибольший прирост ожидаемой полезности.
- **Расчет:** $VoI = E[Полезность | Информация] - E[Полезность | Без Инфо] - Цена(Инфо)$.
- **Интеграция с DS:** Открытые петли ранжируются по убыванию VoI, гарантируя, что критические «неизвестные» не потеряются в шуме.

### 11.2 Трекинг состояний убеждений POMDP
Membria использует **Частично Наблюдаемые Марковские Процессы Принятия Решений (POMDP)** для поддержания вероятностного распределения «истинного консенсуса» команды.
- **Состояния:** `Consensus` (Консенсус), `Surface Agreement` (Поверхностное согласие, скрывающее скепсис), `Misunderstanding` (Непонимание, конфликтующие ментальные модели).
- **Инфузия сигналов:** DBB передает сигналы (скептические вопросы, тишина, задержка действий) в движок байесовского обновления.
- **Скрытые разногласия:** Если $P(Consensus)$ низка, несмотря на явные "+1", система выставляет флаг «Скрытое разногласие» на Decision Surface.

### 11.3 Оптимизатор последовательности решений
Используя **Эвристическую очередь приоритетов (Priority Queue) + Учет неопределенности**, Membria рекомендует оптимальный порядок принятия зависимых решений.
- **Критический путь:** Выявляет решения-бутылочные горлышки (например, «Утверждение бюджета»), блокирующие параллельные потоки работы.
- **Ранжирование:** MCTS был признан избыточным для типичных графов решений (10-50 узлов). Система использует детерминированную очередь приоритетов для ранжирования следующих доступных решений на основе VoI, срочности и блокирующей способности.
- **Симуляция:** Исследует перестановки последовательностей для минимизации «времени простоя рассуждений» и общей длительности проекта.

---

## Приложение A: События обязательств (для аудиторских SMB)

### Юридический отдел или Аудит
- Письмо-обязательство подписано
- Аудиторское заключение отправлено
- Письмо-представление получено
- Дело закрыто в DMS

### Финансы
- Счет выставлен
- Инвойс отправлен
- Списание одобрено

### Коммуникации
- Письмо с мнением отправлено клиенту
- Подтверждение объема работ отправлено
- Одобрение клиента получено

---

## Приложение B: Необходимые интеграции для аудиторских SMB

### MVP (обязательно)
1. Outlook или Exchange — события почты
2. iManage или NetDocuments — события DMS
3. Биллинговая система — финансовые события

### Фаза 2
4. Teams — дополнительный контекст
5. Система управления практикой (Practice management)

Примечание: Slack может быть исключен для аудиторских SMB.

---

## Приложение C: Модели развертывания

| Сегмент | Развертывание |
| --- | --- |
| Персональный | Local-first |
| SMB Аудит | Cloud-first |
| Enterprise | Hybrid или On-prem |

Для SMB:
- IT не хочет поддерживать инфраструктуру
- Облако предпочтительнее
- Важны SOC2 и контроль доступа

---

## Приложение D: Триггеры Системы 2 (Детекция Резонанса)

Membria реализует принцип «Трение по дизайну» (Friction by Design) для борьбы с когнитивными искажениями, такими как **ошибка хайндсайта** и **подтверждающее искажение**.

### D.1 Отслеживаемые паттерны резонанса

| Человеческое искажение | Режим отказа LLM | Сигнал обнаружения |
|------------|------------------|------------------|
| **Подтверждение** | Галлюцинированная поддержка | В графе нет доказательств для цитируемого факта |
| **Якорение** | Фиксация на первом варианте | Трейс рассуждений не содержит альтернатив |
| **Сверхуверенность** | Язык уверенности | Confidence > 0.9 + мало доказательств |
| **Невозвратные затраты** | Ссылка на прошлые инвестиции | Ребра RELIED_ON указывают на замененные решения |

### D.2 Калибровка трения
- **Порог:** Оценка резонанса > 0.6
- **Выход:** Пользователь явно признает риск искажения
- **Охлаждение:** Максимум 2 трения за сессию принятия решений

---

## Резюме

Reasoning Graph — это слой, превращающий мимолетные разговоры с ИИ в устойчивую корпоративную память.

Ключевые принципы:
- Решения, а не документы — фиксируем ход мысли, а не только файлы.
- Commitment Events, а не интерпретация LLM — необратимость берется из внешних фактов.
- Извлечение с учетом бюджета — контролируемый контекст, а не максимум данных.
- Управляемое обучение — LoRA с оценкой, откатом и обоснованием.
- Человек в петле (Human-in-the-loop) — Reasoning Graph никогда не решает сам, а лишь поддерживает решения.

Результат: интеллект суммируется, а не обнуляется.
