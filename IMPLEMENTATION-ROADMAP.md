# Дорожная карта внедрения Decision Intelligence (Implementation Roadmap)

## Обзор (Overview)

В данной дорожной карте описан технический путь внедрения уровня Decision Intelligence как расширения Reasoning Graph Membria. Пять основных компонентов строятся поэтапно, каждый из которых приносит самостоятельную ценность.

---

## Фаза 1: Фундамент (Phase 1: Foundation) (Недели 1-6)

### 1.1 Расширенная схема объекта решения (Extended Decision Object Schema)

**Что:** Добавление 6 новых полей в записи Решений в Graph Memory.

**Изменения:**
```json
{
  "decision_id": "dec_001",
  "statement": "Использовать Вендора X",
  "confidence": 0.75,

  // НОВЫЕ ПОЛЯ
  "value_of_information": {
    "score": 85000.0,      // Float64 в долларах
    "basis": "Влияние на доход, если вендор выбран неверно",
    "computed_at": "2025-01-21T10:00:00Z",
    "sources": ["dec_001_impact_edge"]
  },
  "belief_state": {
    "state": "consensus",
    "prob_true_consensus": 0.60,
    "prob_surface_only": 0.30,
    "prob_misunderstanding": 0.10,
    "confidence": 0.60,
    "last_updated": "2025-01-21T10:05:00Z",
    "signal_history": ["sig_001", "sig_002"]
  },
  "dependencies": {
    "blocks": ["dec_002", "dec_003"],  // какие решения это блокирует
    "blocked_by": [],                  // какими решениями заблокировано это
    "related": ["dec_004"]              // зависимости (не блокирующие)
  },
  "predicted_outcome": null,            // Устанавливается перед исполнением
  "actual_outcome": null,               // Устанавливается после исполнения
  "calibration_delta": null             // предсказание против реальности
}
```

**Реализация:**
- Обновление модели данных Решения в DBB (структура Julia).
- Добавление миграций схемы базы данных (если используется SQL бэкенд).
- Обратная совместимость: новые поля опциональны, по умолчанию null.

**Технологический стек:**
- Язык: Julia (для компонентов RG).
- Графовая БД: **FalkorDB** (основной фундамент знаний для низкозадержечных Cypher-запросов).
- Хранение: Redis-based хранилище через FalkorDB.

**Тестирование:**
- Юнит-тесты: поле VoI может быть null, вычисляться, обновляться.
- Интеграционные тесты: создание Решения с новыми полями и без них в FalkorDB.
- Тесты миграций: существующие узлы в FalkorDB остаются доступными.

**Результат (Deliverable):** Расширенная схема, миграции базы данных, набор тестов.

---

### 1.2 Графовые связи для зависимостей (Graph Relationships for Dependencies)

**Что:** Добавление связей BLOCKS (блокирует) и DEPENDS_ON (зависит от) в граф знаний.

**Изменения:**
```
Decision D1 --[BLOCKS]--> Decision D2
Decision D5 --[BLOCKS]--> Decision D1
Decision D7 --[DEPENDS_ON]--> Decision D5
```

**Реализация:**
- Обновление определений узлов/связей в GraphRAG.
- Добавление функций обхода: `find_blocking(decision_id)`, `find_blocked(decision_id)`.
- Реализация детекции циклов (если A блокирует B, а B блокирует A — это невалидно).

**Технологический стек:**
- Графовая БД: **FalkorDB** (использование GraphBLAS для сверхбыстрых темпоральных обходов).
- Язык запросов: **Cypher** (оптимизирован под цепочки зависимостей Membria).


**Тестирование:**
- Тесты детекции циклов.
- Тесты обхода (поиск транзитивных зависимостей).
- Тесты производительности (скорость запросов для больших графов решений).

**Результат (Deliverable):** Графовая схема, API для обхода связей, валидация.

---

### 1.3 Извлечение сигналов для Состояния убеждений (Signal Extraction for Belief State)

**Что:** Извлечение сигналов, связанных с решениями, из коммуникаций для отслеживания состояния убеждений (belief state).

**Изменения в DBB:**
```
Типы сигналов, извлекаемые из обсуждений:
- EXPLICIT_AGREEMENT: "+1", "согласен", "одобрено"
- EXPLICIT_DISAGREEMENT: "-1", "возражаю", "не согласен"
- SILENCE: человек присутствует, но ничего не сказал
- SKEPTICAL_QUESTION: "откуда мы знаем X?", "как насчет рисков?"
- ACTION_TAKEN: "начинаю наем", "связался с вендором"
- ACTION_DEFERRED: решение принято, но действий нет через 48 часов
- FOLLOW_UP_DISCUSSION: тема открыта повторно после принятия решения

**[НОВОЕ] Фаза 1.3: Качество извлечения сигналов**
- Оценка уверенности (0.0-1.0)
- Культурные модификаторы (Высокий/Низкий контекст)
- Поведенческое подтверждение (Действие должно следовать за Молчанием)
```

**Реализация:**
- Классификатор сигналов на базе LLM (локальный или небольшая специализированная модель).
- Классификация каждого сообщения/комментария, относящегося к решению.
- Хранение сигнала как ссылки на Свидетельство (Evidence) к Решению.
- Включение возможности детекции низкой уверенности (например, > 2 скептических вопроса = низкий уровень консенсуса).

**Технологический стек:**
- Язык: Julia + Python (для инференса LLM).
- Модель: Небольшой специализированный классификатор или модель 7B-13B.
- Хранение: Записи свидетельств сигналов, связанные с Решением.

**Тестирование:**
- Тесты точности извлечения сигналов (точность/полнота на тестовом корпусе).
- Тесты на ложноположительные результаты (убедиться, что молчание не путается с согласием).
- Интеграционные тесты: сигналы обновляют состояние убеждений решения.

**Результат (Deliverable):** Сервис извлечения сигналов, тестовый корпус, начальная калибровка.

---

## Фаза 2: Ценность информации (Phase 2: Value of Information) (Недели 7-12)

### 2.1 Алгоритм оценки VoI (VoI Scoring Algorithm)

**Что:** Вычисление Ценности информации (Value of Information) для каждого решения.

**Необходимые входные данные:**
1. Формулировка решения + альтернативы.
2. Оценочное влияние в случае ошибки: P(ошибка) × стоимость_ошибки.
3. Стоимость сбора дополнительной информации: время + ресурсы.
4. Вторичные эффекты на другие решения.

**Алгоритм:**
```
VoI(D) = P(текущая_уверенность_достаточна) × E[стоимость_при_ошибке]
       - (P(лучшее_решение_с_инфой) - P(текущая_уверенность)) × E[стоимость_при_ошибке]
       - стоимость_сбора_информации

Упрощенно:
VoI ≈ (E[стоимость при ошибке без доп. инфо] - E[стоимость при ошибке с доп. инфо])
     - стоимость_сбора_инфо
```

**Подход к реализации:**
1. **Интервью со стейкхолдерами** (не ML): для каждого типа решения спрашиваем:
   - «Какова стоимость ошибки при неправильном выборе?»
   - «Насколько лучше станет решение с дополнительной информацией?»
   - «Сколько усилий нужно для сбора информации?»
   - Сохраняем как доменные эвристики.

2. **Кодирование в виде правил/шаблонов:**
   ```
   Тип решения: "Выбор вендора"
   Модель стоимости: "годовая_стоимость × годы_обязательств"
   Выгода от инфо: "референсы_вендора_снижают_неопределенность_на_30%"
   Стоимость инфо: "2 недели, 1 человек, $5k"

   Результат: решения по вендорам обычно имеют VoI = $50k - $200k
   ```

3. **Вычисление для каждого решения:**
   - Извлечение типа решения из формулировки.
   - Применение доменной эвристики.
   - Корректировка на основе реального контекста (длительность контракта, размер команды и т.д.).

**Технологический стек:**
- Язык: Julia.
- Хранение: Доменные шаблоны VoI в БД или конфигурационном файле.
- Вычисление: кэшируемое поле в Решении (вычисляется при сохранении, обновляется по запросу).

**Тестирование:**
- Тесты на адекватность: дорогостоящие решения имеют высокий VoI.
- Тесты калибровки: сравнение оценки VoI с реальным влиянием (долгосрочно).
- Тесты сравнения: ранжирование решений по VoI, ручная проверка осмысленности ранжирования.

**Результат (Deliverable):** Сервис вычисления VoI, доменные шаблоны, слой кэширования.

### [НОВОЕ] Фаза 2.3: Петля калибровки VoI
- Отслеживание `VoI_predicted` vs `VoI_actual`
- Триггер "Мудрость толпы" (3+ оценки), если дисперсия > 30%

---

### 2.2 Интеграция VoI с Decision Surface (VoI Integration with Decision Surface)

**Что:** Отображение решений на Decision Surface, отсортированных по VoI.

**Изменения в интерфейсе DS:**
```
Открытые циклы (отсортированы по VoI убыванию):
1. Стратегия ценообразования - VoI: $180k ⭐⭐⭐
   Стоимость при ошибке: $180k/год потери выручки
   Рекомендация: ПРИОРИТЕТ

2. Технологический стек - VoI: $95k ⭐⭐
   Стоимость при ошибке: рефакторинг стоит $95k
   Рекомендация: ПРИОРИТЕТ

3. Формат совещаний - VoI: $2k ⭐
   Стоимость при ошибке: потеря продуктивности на $2k
   Рекомендация: МОЖНО ОТЛОЖИТЬ
```

**Реализация:**
- Добавление оценки VoI в результаты запросов Решений (из Graph Memory).
- API DS возвращает решения, отсортированные по `value_of_information.score` DESC.
- Виджет UI показывает VoI с визуальным индикатором (звезды или градиент).
- Клик для просмотра детализации VoI (компоненты стоимости, обоснование).

**Технологический стек:**
- Бэкенд: Оптимизация запросов GraphRAG (индексация VoI для быстрой сортировки).
- Фронтенд: React-компонент для отображения VoI + модальное окно детализации.
- API: расширение эндпоинта `/decisions` поддержкой `sort_by=voi`.

**Тестирование:**
- Тесты API: сортировка по VoI работает корректно.
- Тесты UI: VoI отображается правильно, клик показывает детализацию.
- Тесты производительности: сортировка по VoI не замедляет списки Решений.

**Результат (Deliverable):** Интеграция в DS, компоненты UI, изменения в API.

---

## Фаза 3: Отслеживание состояния убеждений (Phase 3: Belief State Tracking) (Недели 13-18)

### [НОВОЕ] Фаза 3.0: Период калибровки априорных вероятностей (Prior Calibration)
- 4 недели тихого наблюдения (без оповещений)
- Вычисление априорных вероятностей (priors) для конкретной команды
- Изучение культурного бейслайна (например, частота несогласия)

### 3.1 POMDP Belief State Tracking (Трекинг убеждений)

**Что:** Поддержание распределения вероятностей относительно консенсуса по решению с использованием логики Частично Наблюдаемых Марковских Процессов (POMDP).

**Состояния (States):**
- `true_consensus`: команда искренне согласна.
- `surface_agreement`: люди сказали «да», но на самом деле не верят в это (скрытый скепсис).
- `misunderstanding`: люди поняли решение по-разному.

**Байесовская фильтрация:**
```
Prior (Априорная вероятность): P(state | evidence_history)

Модель правдоподобия (Likelihood model - обученная или созданная вручную):
- P(explicit_agreement | true_consensus) = 0.95
- P(explicit_agreement | surface_agreement) = 0.90
- P(explicit_agreement | misunderstanding) = 0.40

- P(silence | true_consensus) = 0.05
- P(silence | surface_agreement) = 0.30
- P(silence | misunderstanding) = 0.40

- P(skeptical_question | true_consensus) = 0.10
- P(skeptical_question | surface_agreement) = 0.40
- P(skeptical_question | misunderstanding) = 0.80

- P(action_taken | true_consensus) = 0.90
- P(action_taken | surface_agreement) = 0.30
- P(action_taken | misunderstanding) = 0.20

Posterior (Апостериорная вероятность): P(state | new_evidence) ∝ P(new_evidence | state) × P(state)
```

**Реализация:**
1. Инициализация равномерного распределения: P(state) = 1/3 для каждого состояния.
2. Для каждого сигнала обновление:
   ```
   beliefs = beliefs ∝ signal_likelihood × beliefs  // Правило Байеса
   beliefs = beliefs / sum(beliefs)                 // нормализация
   ```
3. Сохранение состояния убеждений в `Decision.belief_state`.
4. Уверенность (Confidence) = max(beliefs) — если < 0.60, выдается предупреждение.

**Технологический стек:**
- Язык: Julia (для численных расчетов).
- Математика: Distributions.jl для Бета/Категориальных распределений.
- Хранение: объект состояния убеждений в формате JSON в БД.

**Тестирование:**
- Калибровка модели правдоподобия: соответствует ли правдоподобие реальности?
- Тесты обновления: при сигналах S1, S2, S3 убеждения обновляются корректно.
- Тесты сходимости: стабилизируются ли убеждения при накоплении свидетельств?
- Тесты на ложноположительные результаты: убедиться в отсутствии оповещений при реально высоком консенсусе.

**Результат (Deliverable):** Реализация байесовской фильтрации, модель правдоподобия, тесты.

---

### 3.2 Интеграция «Сигнал -> Убеждение» (Signal-to-Belief Integration)

**Что:** Соединение извлечения сигналов с обновлением убеждений.

**Конвейер (Pipeline):**
1. Сигнал извлекается (согласно п. 1.3: EXPLICIT_AGREEMENT, SILENCE и т.д.).
2. Сигнал сохраняется как Свидетельство, связанное с Решением.
3. При поступлении сигнала триггерится обновление убеждений.
4. Если уверенность падает ниже порога, в DS добавляется оповещение.

**Реализация:**
- Хук в DBB: после извлечения сигнала вызов `update_belief_state(decision, signal)`.
- Обновления в реальном времени: использование pub/sub или прослушивателя изменений (change event listener).
- Пакетные обновления: периодическое обновление состояния убеждений на основе истории сигналов.

**Технологический стек:**
- Очередь сообщений: Kafka или аналоги (для потоковой передачи событий).
- ИЛИ: триггеры/колбэки базы данных для более простых инсталляций.

**Тестирование:**
- Интеграционные тесты: извлечение сигнала -> обновление убеждения -> оповещение в DS.
- Сквозной тест: добавление скептического вопроса, наблюдение за падением уверенности в убеждении.

**Результат (Deliverable):** Конвейер «сигнал-убеждение», логика оповещений.

---

### 3.3 Decision Surface — Оповещения о скрытых разногласиях (Hidden Disagreement Alerts)

**Что:** DS показывает оповещение, когда решение кажется принятым, но уверенность в консенсусе низкая.

**Изменения в UI:**
```
Решение: "Нанять 5 инженеров во втором квартале"
Статус: ✓ ОДОБРЕНО

Уверенность в консенсусе: 40% ⚠️
  - Истинный консенсус: 40%
  - Только поверхностное согласие: 35%
  - Непонимание: 25%

История сигналов:
  ✓ 3 человека согласились
  ⓘ 1 человек промолчал
  ❓ 2 скептических вопроса
  ✗ 0 начатых задач

Рекомендация: Вернуть на явное обсуждение перед исполнением.
```

**Реализация:**
- Добавление `belief_state` в результаты запросов Решений.
- DS показывает уверенность как визуальный индикатор (зеленый/желтый/красный).
- Клик для просмотра детализации сигналов.
- Оповещение отправляет уведомление владельцу решения, если уверенность < порога.

**Тестирование:**
- UI корректно отображает уверенность.
- Оповещение срабатывает при низкой уверенности.
- Скрытое разногласие обнаруживается при калибровке (пост-мортем).

**Результат (Deliverable):** Визуализация состояния убеждений в DS, система оповещений, уведомления владельцу решения.

---

## Фаза 4: Калибровка предположений и обучение (Phase 4: Assumption Calibration & Learning) (Недели 19-26)

### 4.1 Отслеживание исходов предположений (Assumption Outcome Tracking)

**Что:** Связывание исходов (outcomes) с предположениями, обновление распределений убеждений.

**Изменения в схеме:**
```
Assumption {
  assumption_id,
  statement: "Вендор X надежен",
  confidence: 0.75,  // начальная
  prior_belief: Beta(α, β),

  outcomes: [
    {
      decision_id: "dec_001",
      outcome: "success",    // успех | неудача | смешано
      recorded_at: timestamp,
      impact: "Вендор доставил вовремя"
    }
  ]
}
```

**Реализация:**
1. При фиксации исхода решения обновляются связанные предположения.
   ```
   decision = Decision(statement="Использовать вендора X")
   assumptions = decision.assumptions

   for assumption in assumptions:
     if "Вендор X" in assumption.statement:
       update_assumption_belief(assumption, outcome)
   ```
2. Обновление бета-распределения:
   ```
   Outcome("success"): Beta(α, β) → Beta(α+1, β)
   Outcome("failure"): Beta(α, β) → Beta(α, β+1)
   ```
3. Пересчет уверенности на основе бета-распределения:
   ```
   confidence = E[Beta(α, β)] = α / (α + β)
   ```

**Технологический стек:**
- Язык: Julia + Distributions.jl.
- Хранение: массив исходов (outcomes) в узле Предположения (Assumption).

**Тестирование:**
- Корректность обновления бета-распределения.
- Точность расчета уверенности.
- Интеграция: исход решения -> обновление убеждения в предположении.

**Результат (Deliverable):** Отслеживание исходов предположений, обновление убеждений через Бета-распределение.

**[НОВОЕ] Стратифицированные обновления:** Взвешивание исходов по свежести и совпадению конфаундеров (confounders).

---

### 4.2 Аналитика калибровки (Calibration Analytics)

**Что:** Агрегирование данных калибровки по решениям, выявление паттернов.

**Аналитические запросы:**
```
Отчет по калибровке команды (Product team):
- 20 решений за 6 месяцев
- Предсказанная уверенность: [75%, 82%, 70%, 88%, ...] (средняя 76%)
- Фактическая частота успеха: 78%
- Разрыв калибровки (Calibration gap): -2% (небольшая избыточная уверенность)
- Хорошая калибровка, небольшой перекос в рискованных решениях

Калибровка по типу решения (Наем):
- 15 решений по найму
- Предсказанная уверенность: средняя 82%
- Фактическая частота успеха: 52% (сотрудники проработали > 6 месяцев)
- Разрыв калибровки: +30% (значительная избыточная уверенность)
- Паттерн: команда переоценивает успех при найме

Индивидуальная калибровка (CTO):
- 10 инфраструктурных решений
- Предсказание: среднее 80%, Реальность: 85%
- Хорошая калибровка, небольшая недостаточная уверенность
- Паттерн: оценкам CTO в инфраструктуре можно доверять
```

**Реализация:**
1. Запрос: все решения с зафиксированными исходами в диапазоне времени.
   ```
   SELECT decision WHERE status="executed" AND actual_outcome NOT NULL
   ```
2. Агрегация предсказаний против реальности:
   - Группировка по: команде, типу решения (decision_type), сотруднику, диапазону дат.
   - Расчет: средняя(предсказанная_уверенность), частота_успеха(actual_outcome).
   - Расчет: gap (разрыв) = предсказанная - фактическая.
3. Выявление паттернов:
   - Если наблюдается систематический перекос (например, разрыв > 20%), помечать как систематическое искажение (bias).
   - Генерация кандидата на LoRA: "hiring_confidence_reducer" (снижение уверенности в найме).

**Технологический стек:**
- Язык: Julia или Python.
- Запросы к БД: GraphRAG или SQL.
- Анализ: DataFrames.jl или pandas.

**Тестирование:**
- Корректность агрегирующих запросов.
- Точность расчета разрыва калибровки.
- Эвристики детекции паттернов.

**Результат (Deliverable):** Сервис аналитики калибровки, дашборды.

---

### 4.3 Генерация кандидатов LoRA (LoRA Candidate Generation)

**Что:** Автоматическое предложение адаптеров LoRA на основе паттернов калибровки.

**Процесс:**
1. Детекция систематического искажения:
   ```
   IF (calibration_gap > 20% AND decision_count > 10)
   THEN create_LoRA_candidate(
     domain: decision_type,
     issue: "overconfident" | "underconfident",
     magnitude: calibration_gap,
     sample_size: decision_count
   )
   ```
2. Генерация Записи обоснования LoRA (LoRA Justification Record):
   ```
   LoRA Candidate: hiring_decision_confidence_reducer

   Причина: Систематическая избыточная уверенность в решениях по найму.
   - Выборка: 15 решений по найму за 6 месяцев.
   - Предсказанная ср. уверенность: 82%
   - Фактический успех: 52%
   - Разрыв (Gap): +30%

   Ожидаемый эффект:
   - Применение множителя 0.70× к оценкам уверенности в найме.
   - Ожидаемый новый разрыв: ~10% (допустимый диапазон).
   - Риск: Может занижать оценки хороших перспектив найма.

   Рекомендация: Одобрить для канареечного развертывания (canary rollout).
   ```
3. Представление человеку на одобрение:
   - DS показывает: "Кандидат LoRA готов к ревью: hiring_confidence_reducer".
   - Ревьюер может: Одобрить для canary -> Продвинуть (Promote) -> Мониторить откат.

**Технологический стек:**
- Язык: Julia.
- Ворклоу: асинхронная задача (cron или триггер по событию).
- Хранение: кандидаты LoRA в БД.

**Тестирование:**
- Корректность генерации кандидатов.
- Полнота записи обоснования.
- Интеграция ворклоу с процессом одобрения LoRA.

**Результат (Deliverable):** Генерация кандидатов LoRA, записи обоснований.

---

## Фаза 5: Оптимизатор последовательности решений (Phase 5: Decision Sequencing Optimizer) (Недели 27-32)

### 5.1 Граф зависимостей и анализ блокировок (Dependency Graph & Blocking Analysis)

**Что:** Анализ зависимостей решений, вычисление критического пути.

**Структура данных:**
```
Decision D1 ← формулировка: "Технологический стек"
  блокирует: [D2, D3, D4]

Decision D5 ← формулировка: "Бюджет"
  блокирует: [D1, D6]

Decision D7 ← формулировка: "Вендор"
  блокирует: [D8]

Граф зависимостей:
D5 → D1 → [D2, D3, D4]
D5 → D6
D7 → D8
```

**Алгоритм — Метод критического пути (CPM):**
1. Топологическая сортировка: поиск валидных последовательностей.
2. Расчет самого раннего времени начала (EST) для каждого решения:
   ```
   EST(D) = max(EST(предшественники)) + длительность(предшественник)
   ```
3. Расчет самого позднего времени начала (LST):
   ```
   LST(D) = min(LST(преемники)) - длительность(D)
   ```
4. Критический путь: решения, где EST = LST (отсутствие резерва времени).
5. Общее время проекта: EST(последнее_решение).

**Реализация:**
```julia
function critical_path(decisions::Vector{Decision})
  # Построение графа зависимостей
  graph = build_dependency_graph(decisions)

  # Топологическая сортировка
  ordered = topological_sort(graph)

  # Расчет EST
  est = Dict()
  for d in ordered
    est[d.id] = maximum(est[p.id] for p in predecessors(d))
  end

  # Расчет LST
  lst = Dict()
  for d in reverse(ordered)
    lst[d.id] = minimum(lst[s.id] for s in successors(d))
  end

  # Критический путь
  critical = [d for d in decisions if est[d.id] == lst[d.id]]
  total_time = est[last_decision]

  return (critical_path=critical, total_time=total_time, est=est, lst=lst)
end
```

**Технологический стек:**
- Язык: Julia.
- Библиотека графов: Graphs.jl.
- Хранение: граф зависимостей решений из Графа знаний.

**Тестирование:**
- Корректность CPM на тестовых графах.
- Точность идентификации критического пути.
- Производительность на больших графах решений.

**Результат (Deliverable):** Алгоритм CPM, реализация, тесты.

---

### 5.2 Рекомендация последовательности с учетом неопределенности (Очередь приоритетов)

**Что:** Ранжирование доступных следующих решений с использованием очереди приоритетов (Priority Queue) на основе VoI, неопределенности и блокирующей способности.

**Почему:** Поиск по дереву Монте-Карло (MCTS) был признан избыточным для типичных графов решений (10-50 узлов). Детерминированная эвристическая очередь приоритетов обеспечивает 90% выгоды при сложности O(N log N).

**Функция оценки (Score Function):**
```
Score(D) = (VoI(D) * Urgency(D)) / Duration(D) * UncertaintyMultiplier(D)
```
Где:
- `Urgency` (Срочность): 1.0 если на критическом пути, < 1.0 в противном случае.
- `UncertaintyMultiplier` (Множитель неопределенности): выше, если решение D снижает общую энтропию (например, разблокирует много ветвей).

**Алгоритм:**
```julia
function recommend_sequence(decisions, dependencies):
  # 1. Идентификация "готового набора" (разблокированные решения)
  ready_queue = PriorityQueue()
  
  # 2. Оценка и постановка в очередь
  for d in decisions:
    if is_unblocked(d):
      score = calculate_heuristic_score(d)
      enqueue(ready_queue, d, score)
      
  recommendation = []
  
  # 3. Жадный цикл выбора
  while !isempty(ready_queue):
    best = dequeue!(ready_queue)
    push!(recommendation, best)
    
    # Симуляция завершения
    for successor in successors(best):
      remove_dependency(successor, best)
      if is_unblocked(successor):
         score = calculate_heuristic_score(successor)
         enqueue(ready_queue, successor, score)
          
  return recommendation
end
```

**Реализация:**
1. Реализация эвристик оценки (VoI, флаг критического пути).
2. Поддержание живой очереди приоритетов состояний заблокировано/разблокировано.
3. Возврат простого упорядоченного списка.

**Технологический стек:**
- Язык: Julia (DataStructures.jl).
- Входные данные: узлы Graph Memory.

**Тестирование:**
- Сравнение «Naive FIFO» против «Priority Queue» по общей накопленной ценности во времени.
- Проверка того, что элементы критического пути получают более высокий приоритет.

**Результат (Deliverable):** Движок последовательности на базе очереди приоритетов.

---

### 5.3 Интеграция последовательности в Decision Surface (Sequencing Integration with Decision Surface)

**Что:** DS показывает рекомендуемую последовательность решений и ожидаемое ускорение.

**Изменения в UI:**
```
Оптимизатор последовательности решений

Текущее состояние:
- 5 ожидающих решений
- 3 заблокированных решения
- Оценочное время завершения: 6 недель

Наивный подход (FIFO):
→ D1: Техстек (1 неделя)
  → D5: Бюджет (блокирует D1, в процессе ожидания)
  ✗ [Заблокировано, потеря 1 недели]

Рекомендуемая последовательность (Priority Queue):
→ D5: Бюджет (1 неделя) [Оценка: 95 - Критический путь]
→ D1: Техстек (1 неделя) [Оценка: 88 - Высокий VoI]
→ [D2, D3, D4 параллельно: 2 недели]
→ D7: Вендор (1 неделя)

Ожидаемое завершение: 3 недели (на 50% быстрее)

Критический путь: D5 → D1 → [D2-D4]
Не критично: D7 (можно начинать в любое время)
```

**Реализация:**
- Запрос GraphRAG: получение всех ожидающих/заблокированных решений + зависимостей.
- Расчет рекомендации: вызов `sequencing_recommender()`.
- Форматирование ответа: последовательность с пояснением.
- API DS: `/decisions/recommend-sequence`.
- UI: представление рекомендуемой последовательности в виде таймлайна.

**Тестирование:**
- E2E-тест: запрос решений, расчет последовательности, отображение в UI.
- Тест на корректность: сравнение рекомендации с ручным анализом.
- Тест производительности: завершается ли расчет за < 1 секунды для 20 решений?

**Результат (Deliverable):** Интеграция в DS, API, UI-компонент таймлайна.

---

## Фаза 6: Интеграция и валидация (Phase 6: Integration & Validation) (Недели 33-38)

### 6.1 Сквозное тестирование (End-to-End Testing)

**Сценарий 1: Полный жизненный цикл решения**
1. Пользователь принимает решение в Slack: «Использовать вендора X (уверенность 75%)».
2. DBB фиксирует, создает запись Решения.
3. Вычисляется VoI: $85k (решение имеет высокое влияние).
4. Инициализируется состояние убеждения: 60% консенсуса (некоторые участники промолчали).
5. DS показывает: «Вендор X выбран (VoI=$85k, консенсус=60%)».
6. Через 6 месяцев: вендор успешно справляется.
7. Исход фиксируется, убеждение в предположении обновляется.
8. Отчет по калибровке: CTO хорошо калиброван в решениях по вендорам.
9. LoRA не требуется (данные уже точны).

**Сценарий 2: Оповещение о низком консенсусе**
1. Решение: «Запустить продукт во втором квартале».
2. DBB фиксирует: «одобрено» -> уверенность 0.75.
3. Поступают сигналы:
   - «+1 от PM»
   - Молчание от VP Eng
   - «А как же техдолг?» от инженера
4. Убеждение обновлено: 40% истинного консенсуса.
5. Оповещение DS: «Низкая уверенность в решении. Рекомендуется обсуждение».
6. Команда обсуждает, явно разрешает опасения.
7. Последующее сообщение: «Одобрено, вопрос с техдолгом решен».
8. Убеждение обновлено: 85% консенсуса.
9. Выполнение без рисков.

**Сценарий 3: Оптимизация последовательности**
1. 5 решений в ожидании: Бюджет, Техстек, Вендор, Наем, Стратегия данных.
2. Зависимости: Бюджет блокирует Техстек и Вендора; Техстек блокирует Наем.
3. Текущий порядок занял бы 6 недель (много блокировок).
4. Оптимизатор рекомендует: Бюджет → Техстек → Наем (+ Стратегия данных параллельно).
5. Ожидаемое время: 3 недели.
6. Команда следует рекомендации.
7. Отслеживается фактическое время, подтверждается эффективность рекомендации.

**Тестирование:**
- Запуск сценариев в тестовой среде.
- Измерение точности рекомендаций.
- Сбор качественной обратной связи (помогло ли это?).

---

### 6.2 Пилотная программа (Pilot Program)

**Цель:** 1-2 команды ранних последователей (внутренние или лояльные клиенты).

**Масштаб:**
- Размер команды: 5-20 человек.
- Частота принятия решений: 1-5 решений в неделю.
- Продолжительность: 2-3 месяца.

**Метрики:**
- Ранжирование по VoI: разрешаются ли решения с высоким VoI быстрее?
- Состояние убеждений: сколько скрытых разногласий выявлено?
- Калибровка: точны ли предсказания?
- Последовательность: фактическое время против рекомендаций?
- Адаптация: % решений с включенными интеллектуальными сигналами.

**Результат (Deliverable):** Отчет по пилоту, извлеченные уроки, отзыв клиента.

---

## [НОВОЕ] Фаза 7: Движок вмешательства в искажения (Debiasing Intervention Engine) (Недели 39-44)

**(Работает на базе детекции резонанса "Системы 2")**

### 7.1 Библиотека вмешательств
- Якорение → "Рассмотрите 3 альтернативы"
- Подтверждение → Промпт "Адвокат дьявола"
- Сверхуверенность → Упражнение "Пре-мортем"
- Невозвратные затраты → Рефрейминг "Чистый лист"

### 7.2 Доставка вмешательств
- Триггерится при **Оценке резонанса > 0.6** (см. Архитектуру, Приложение D)
- Инлайн-промпты в Decision Surface
- Обязательные поля перед подтверждением решения

### 7.3 Калибровка вмешательств
- A/B тестирование вмешательств
- Отключение неэффективных триггеров для каждой команды

---

### 6.3 Подготовка к эксплуатации (Production Hardening)

**Что:** Обеспечение надежности, производительности и безопасности для продакшна.

**Чек-лист:**
- [ ] Обработка ошибок: корректная деградация, если расчет VoI не удался.
- [ ] Производительность: кэширование VoI, обновлений состояния убеждений.
- [ ] Мониторинг: отслеживание точности извлечения сигналов, стабильности убеждений.
- [ ] Резервное копирование: ежедневный бэкап данных decision intelligence.
- [ ] Аудит: все вычисления логируются и воспроизводимы.
- [ ] Приватность: состояние убеждений и сигналы приватны для команды.
- [ ] Откат (Rollback): возможность отключения функций без потери данных.

**Тестирование:**
- Нагрузочный тест: 1000 решений с непрерывным обновлением сигналов.
- Тест на отказ (Failover): перезагрузка сервиса, проверка целостности данных.
- Тест безопасности: неавторизованный пользователь не может видеть решения других команд.

**Результат (Deliverable):** Чек-лист развертывания в продакшн, инструкции (runbooks).

---

## Резюме архитектуры (Architecture Summary)

```
┌────────────────────────────────────────────────────┐
│ Reasoning Graph - Расширенный                      │
├────────────────────────────────────────────────────┤
│                                                    │
│ Фаза 1: Фундамент                                  │
│  ├─ Расширенная схема Решения                      │
│  ├─ Графовые зависимости (связь BLOCKS)             │
│  └─ Извлечение сигналов для состояния убеждений    │
│                                                    │
│ Фаза 2: Ценность информации (VoI)                  │
│  ├─ Вычисление VoI                                 │
│  ├─ Доменные эвристики/шаблоны                     │
│  └─ Интеграция в DS (ранжирование)                 │
│                                                    │
│ Фаза 3: Отслеживание состояния убеждений           │
│  ├─ POMDP Belief State Tracking                    │
│  ├─ Конвейер «сигнал-убеждение»                    │
│  └─ Оповещения о скрытых разногласиях              │
│                                                    │
│ Фаза 4: Калибровка предположений                   │
│  ├─ Отслеживание исходов                           │
│  ├─ Аналитика калибровки                           │
│  └─ Генерация кандидатов LoRA                      │
│                                                    │
│ Фаза 5: Оптимизация последовательности решений     │
│  ├─ Метод критического пути (CPM)                  │
│  ├─ Очередь приоритетов (Priority Queue)           │
│  └─ Визуализация таймлайна в DS                    │
│                                                    │
│ Фаза 6: Интеграция и валидация                     │
│  ├─ E2E тестирование                               │
│  ├─ Пилотная программа                             │
│  └─ Подготовка к эксплуатации (Hardening)          │
│                                                    │
└────────────────────────────────────────────────────┘
```

---

## График и ресурсы (Timeline & Resources)

| Фаза | Продолжительность | Размер команды | Основные результаты |
|-------|----------|-----------|------------------|
| 1 | 6 недель | 2 инженера | Схема, миграции, сигналы |
| 2 | 6 недель | 1 инженер + доменные эксперты | Алгоритм VoI, интеграция в DS |
| 3 | 6 недель | 1-2 инженера | Байесовская фильтрация, оповещения |
| 4 | 8 недель | 1 инженер + ML-инженер | Аналитика калибровки, конвейер LoRA |
| 5 | 6 недель | 1 инженер + эксперт по алгоритмам | CPM, Priority Queue, визуализация |
| 6 | 6 недель | 2 инженера + QA | Тестирование, пилот, hardening |
| **Всего** | **~38 недель** | **2-4 инженера в ср.** | **Полный Decision Intelligence** |

---

## Метрики успеха (Success Metrics)

| Метрика | Цель | Метод |
|--------|--------|--------|
| Решения с высоким VoI принимаются в 2 раза быстрее | Ускорение 2.0x | A/B тест старого и нового DS |
| Скрытые разногласия обнаружены до исполнения | >80% потенциальных проблем | Пост-мортем анализ |
| Калибровка команды улучшается | Улучшение точности на 10-15% | Ретроспектива за 6 месяцев |
| Рекомендации по последовательности приняты | >70% внедрения | Опросы пользователей + трекинг |
| Надежность системы | >99.5% аптайм | Мониторинг-дашборды |

---

## Смягчение рисков (Risk Mitigation)

| Риск | Смягчение |
|------|-----------|
| Расчет VoI слишком сложен или неточен | Начать с простых эвристик, валидировать с экспертами |
| Обновления убеждений слишком частые/шумные | Использовать дебаунсинг, порог уверенности сигналов |
| Рекомендации по последовательности игнорируются | Предоставлять сильные доказательства, пилот с лояльными командами |
| Переобучение LoRA на искажениях команды | Требовать проверочный датасет, канареечный деплой, быстрый откат |
| Опасения по поводу приватности трекинга | Шифрование при хранении, RBAC, аудит-логи, прозрачность данных |

---

## Зависимости и блокираторы (Dependencies & Blockers)

- **Reasoning Graph должен быть развернут**: фиксация решений работает, графовая память функционирует.
- **Запросы GraphRAG стабильны**: извлечение решений и зависимости работают достаточно быстро.
- **Доступна доменная экспертиза**: для шаблонов VoI и эвристик калибровки.
- **Инфраструктура LoRA готова**: для Фазы 4 (обучение LoRA, canary, rollback).

---

## Дорожная карта после запуска (Post-Launch Roadmap)

После полного внедрения:

1. **Непрерывное обучение**: калибровка улучшается со временем по мере накопления данных.
2. **Доменная специализация**: отдельные адаптеры LoRA для разных типов решений.
3. **Персонализированные модели**: настройка скоринга уверенности под конкретную команду.
4. **Прогностические алерты**: предсказание рискованных решений до их выполнения.
5. **Объяснимый ИИ (Explainable AI)**: объяснение причин приоритизации или флага решения.
6. **Интеграция с ворклоу**: триггер действий для решений с высоким VoI (эскалация, уведомление).
